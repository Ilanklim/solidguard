Vaulnerability Name: signature_verification
Title: Signature Verification Exploits

Relationships:
- Related Concept: Replay Protection
- Related Concept: Signature Authenticity Validation

Description:
Signature verification exploits occur when there are flaws in the process of validating signatures, which allows attackers to forge or replay valid signatures. These exploits lead to unauthorized transactions, as the system incorrectly verifies the signatureâ€™s authenticity.

The Wormhole Bridge hack in 2022 demonstrates how signature verification can fail. In this attack, the actor forged a valid signature to exploit the bridge. The attacker created their own account which stored the same data as Instructions sysvar and was able to impersonate a valid signature.

Remediation:
Use a secure signature scheme like EIP-712 to reduce the risk of signature verification vulnerabilities. Implement strong input validation checks for signatures. Use nonces to prevent replay attacks.

References:
- Wormhole Bridge Hack (2022)

Vulnerable Example:
pragma solidity ^0.8.0;

contract VulnerableSignatureCheck {
    mapping(bytes32 => bool) public usedHashes;

    // Weak or incomplete signature validation can allow forgery or replay
    function processSignedAction(bytes32 hash, bytes memory signature) public {
        require(!usedHashes[hash], "Replay detected");

        address signer = recoverSigner(hash, signature);
        require(signer != address(0), "Invalid signature");

        usedHashes[hash] = true;
    }

    function recoverSigner(bytes32 hash, bytes memory sig) internal pure returns (address) {
        // Placeholder representing an unsafe or incomplete recovery method
        return address(0);
    }
}

Fixed Example:
pragma solidity ^0.8.0;

contract SafeSignatureCheck {
    mapping(bytes32 => bool) public usedHashes;

    function processSignedAction(bytes32 hash, bytes memory signature, uint256 nonce) public {
        require(!usedHashes[hash], "Replay detected");

        // Strong signature validation using a secure scheme such as EIP-712
        address signer = recoverSigner(hash, signature);
        require(signer != address(0), "Invalid signature");

        // Nonce-based replay protection
        usedHashes[hash] = true;
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        // Placeholder for secure signature recovery logic
        return address(0);
    }
}
