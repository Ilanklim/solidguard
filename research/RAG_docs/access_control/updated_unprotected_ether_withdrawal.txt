Vulnerability Name: access_control
Title: Missing or Insufficient Access Controls (AttackType: access_control)
SWC: SWC-105, SWC-118
CWE: CWE-284 (Improper Access Control), CWE-665 (Improper Initialization)

Description
-----------
Privileged operations such as withdrawing Ether/tokens, changing ownership, collecting fees, modifying critical parameters, or initializing contract state are not restricted by proper access control checks. This allows any caller to execute them. Common causes include missing modifiers, misnamed constructors (Solidity <0.7), exposed initializer functions, or flawed custom ownership logic.

Key Patterns
------------
- Sensitive functions (withdraw, migrate, collectFees, changeOwner, selfdestruct) without require() or onlyOwner modifiers
- Constructor name does not match contract name (pre-0.7 Solidity)
- Public initializer or setup function that should only be called once
- Ownership-granting functions (e.g. newOwner, addAdmin) missing access control
- Use of tx.origin for authorization
- State variables (owner, fees, multipliers) modifiable by anyone

Impact
------
Attackers can:
- Drain all Ether or tokens from the contract
- Steal permanent ownership or privileged roles
- Re-initialize the contract, locking out legitimate owners
- Disrupt or destroy contract functionality

Remediation
-----------
- Use OpenZeppelin’s Ownable, AccessControl, or audited multi-sig patterns
- Protect every privileged function with appropriate modifiers or require checks
- Always use the `constructor` keyword in Solidity ≥0.7
- For upgradeable contracts, use Initializable and proper initializer guards
- Never rely on function name matching for constructor behavior in older Solidity
- Validate ownership on every state-changing operation

References
----------
- SWC Registry: Unprotected Ether Withdrawal
  https://swc-registry.io/docs/SWC-105
- SWC Registry: Incorrect Constructor Name
  https://swc-registry.io/docs/SWC-118
- OpenZeppelin Access Control Documentation
  https://docs.openzeppelin.com/contracts/4.x/access-control

Samples
=======

Example: simple_ether_drain.sol (vulnerable — access_control)
Type: vulnerable
Notes:
No access control on withdrawAllAnyone() — any caller can drain the full balance.
```solidity
pragma solidity ^0.4.22;

contract SimpleEtherDrain {
    function withdrawAllAnyone() public {
        msg.sender.transfer(address(this).balance);
    }

    function () public payable {}
}
Example: rubixi.sol (vulnerable — access_control)
Type: vulnerable
Notes:
Constructor is named DynamicPyramid() instead of Rubixi(), making it a public function. Anyone can call it to become creator and drain collected fees.
soliditypragma solidity ^0.4.22;

contract Rubixi {
    uint private balance = 0;
    uint private collectedFees = 0;
    uint private feePercent = 10;
    uint private pyramidMultiplier = 300;
    uint private payoutOrder = 0;
    address private creator;

    function DynamicPyramid() public {
        creator = msg.sender;
    }

    modifier onlyowner {
        if (msg.sender == creator) _;
    }

    struct Participant {
        address etherAddress;
        uint payout;
    }

    Participant[] private participants;

    function() public payable {
        init();
    }

    // ... (rest of pyramid logic omitted for brevity in notes, full code preserved)
    function collectAllFees() public onlyowner {
        if (collectedFees == 0) revert();
        creator.send(collectedFees);
        collectedFees = 0;
    }

    function changeOwner(address _owner) public onlyowner {
        creator = _owner;
    }
}
Example: wallet_03_wrong_constructor.sol (vulnerable — access_control)
Type: vulnerable
Notes:
Constructor misnamed as initWallet() — anyone can call it and become creator, then migrate all funds.
soliditypragma solidity ^0.4.24;

contract Wallet {
    address creator;
    mapping(address => uint256) balances;

    function initWallet() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public {
        require(amount <= balances[msg.sender]);
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }

    function migrateTo(address to) public {
        require(creator == msg.sender);
        to.transfer(address(this).balance);
    }
}
Example: multiowned_vulnerable.sol (vulnerable — access_control)
Type: vulnerable
Notes:
newOwner() lacks onlyOwner modifier — anyone can add themselves as owner and withdraw funds.
soliditypragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping (address => address) public owners;

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != 0);
        _;
    }

    // Missing onlyOwner!
    function newOwner(address _owner) external returns (bool) {
        require(_owner != 0);
        owners[_owner] = msg.sender;
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner public {
        msg.sender.transfer(address(this).balance);
    }

    function() payable external {}
}
Example: wallet_02_refund_nosub.sol (vulnerable — access_control)
Type: vulnerable
Notes:
refund() sends funds but never resets balance — enables unlimited withdrawals.
soliditypragma solidity ^0.4.24;

contract Wallet {
    address creator;
    mapping(address => uint256) balances;

    constructor() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }

    function refund() public {
        msg.sender.transfer(balances[msg.sender]);
        // Missing: balances[msg.sender] = 0;
    }

    function migrateTo(address to) public {
        require(creator == msg.sender);
        to.transfer(address(this).balance);
    }
}
Example: tokensalechallenge.sol (vulnerable — arithmetic)
Type: vulnerable
Notes:
Integer overflow in buy() calculation — not access control. Primary category: arithmetic.
soliditypragma solidity ^0.4.21;

contract TokenSaleChallenge {
    mapping(address => uint256) public balanceOf;
    uint256 constant PRICE_PER_TOKEN = 1 ether;

    function buy(uint256 numTokens) public payable {
        require(msg.value == numTokens * PRICE_PER_TOKEN);
        balanceOf[msg.sender] += numTokens;
    }
}
Example: multiowned_not_vulnerable.sol (safe — access_control)
Type: safe
Notes:
newOwner() correctly protected — secure multi-ownership implementation.
soliditypragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping (address => address) public owners;

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != 0);
        _;
    }

    function newOwner(address _owner) onlyOwner external returns (bool) {
        require(_owner != 0);
        owners[_owner] = msg.sender;
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner public {
        msg.sender.transfer(address(this).balance);
    }

    function() payable external {}
}
Example: wallet_01_ok.sol (safe — access_control)
Type: safe
Notes:
Proper access controls: user withdrawals limited, refund() resets balance, emergency migration only by creator.
soliditypragma solidity ^0.4.24;

contract Wallet {
    address creator;
    mapping(address => uint256) balances;

    constructor() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }

    function refund() public {
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }

    function migrateTo(address to) public {
        require(creator == msg.sender);
        to.transfer(address(this).balance);
    }
}