Vaulnerability Name: arithmatic
Title: Arithmetic & Math Logic Errors

Relationships:
- SWC-101: Integer Overflow and Underflow
- CWE-682: Incorrect Calculation
- CWE-190: Integer Overflow or Wraparound
- EthTrust Levels:
  - [S] No Overflow/Underflow
  - [M] Safe Arithmetic Operations
  - [M] Documented Defensive Coding Practices

Description:
Math errors in smart contracts are a result of incorrect calculations, including overflow and underflow issues, rounding mistakes, precision loss, and broader accounting or logic errors. These mistakes can cause a contract to mis-handle core values—such as balances, interest rates, token reserves, and fees—creating exploitable discrepancies that attackers can take advantage of.

A real-world example comes from the Uranium Finance exploit of April 2021, where the project accidentally modified a constant used in its AMM math. In the updated UraniumPair contract, developers changed two constants from 1,000 to 10,000, but failed to adjust a corresponding denominator later in the formula. According to the REKT analysis (pages 1–3), this small mismatch let an attacker swap 1 wei of an input token for roughly 98% of the output token supply, breaking the Uniswap-style x * y = k invariant and resulting in about $57M in losses.

Remediation:
- Use Solidity 0.8.0+ (built-in overflow/underflow checks)
- Use SafeMath or equivalent libraries for <0.8.x
- Maintain consistency when modifying AMM or financial formulas
- Perform multiplication before division to avoid truncation
- Use fixed-point math libraries
- Apply invariant testing and fuzzers to detect math inconsistencies

References:
- SWC-101: Integer Overflow and Underflow
- Ethereum Smart Contract Best Practices: Arithmetic Safety
- REKT: Uranium Finance Exploit (2021)

Vulnerable Example:
pragma solidity ^0.6.0;

contract RoundingIssue {
    uint256 public price = 125;
    uint256 public totalSupply = 1e18;

    function buy(uint256 amount) public {
        uint256 cost = (amount / 100) * price;
        totalSupply += amount;
    }
}

Fixed Example:
pragma solidity ^0.8.0;

contract SafeMathLogic {
    uint256 public price = 125;
    uint256 public totalSupply = 1e18;

    function buy(uint256 amount) public {
        require(amount > 0);
        uint256 cost = (amount * price) / 100;
        totalSupply += amount;
    }
}

Real Exploit Pseudocode (Uranium Finance):
uint256 constant FEE_NUMERATOR = 10000;  // modified
uint256 constant FEE_DENOMINATOR = 1000; // NOT modified

// Mismatched values caused AMM math to break.
